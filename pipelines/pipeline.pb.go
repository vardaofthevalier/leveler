// Code generated by protoc-gen-go. DO NOT EDIT.
// source: pipeline.proto

/*
Package pipelines is a generated protocol buffer package.

It is generated from these files:
	pipeline.proto
	integration.proto

It has these top-level messages:
	Loggable
	Log
	PipelineScmConfig
	PipelineStorageConfig
	S3Data
	NexusData
	PipelineInput
	PipelineOutput
	PipelineAlertConfig
	PipelineStep
	BasicPipeline
	CicdPipeline
	Integration
	IntegrationsList
	BitbucketAccessConfig
	GithubAccessConfig
	AWSConfig
	NexusConfig
	SlackConfig
*/
package pipelines

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type LogProducer int32

const (
	LogProducer_pipeline LogProducer = 0
	LogProducer_job      LogProducer = 1
)

var LogProducer_name = map[int32]string{
	0: "pipeline",
	1: "job",
}
var LogProducer_value = map[string]int32{
	"pipeline": 0,
	"job":      1,
}

func (x LogProducer) String() string {
	return proto.EnumName(LogProducer_name, int32(x))
}
func (LogProducer) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Loggable struct {
	Kind LogProducer `protobuf:"varint,1,opt,name=kind,enum=pipelines.LogProducer" json:"kind,omitempty"`
}

func (m *Loggable) Reset()                    { *m = Loggable{} }
func (m *Loggable) String() string            { return proto.CompactTextString(m) }
func (*Loggable) ProtoMessage()               {}
func (*Loggable) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Loggable) GetKind() LogProducer {
	if m != nil {
		return m.Kind
	}
	return LogProducer_pipeline
}

type Log struct {
	Message string `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
}

func (m *Log) Reset()                    { *m = Log{} }
func (m *Log) String() string            { return proto.CompactTextString(m) }
func (*Log) ProtoMessage()               {}
func (*Log) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Log) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type PipelineScmConfig struct {
	// Types that are valid to be assigned to Scm:
	//	*PipelineScmConfig_Bitbucket
	//	*PipelineScmConfig_Github
	Scm isPipelineScmConfig_Scm `protobuf_oneof:"scm"`
}

func (m *PipelineScmConfig) Reset()                    { *m = PipelineScmConfig{} }
func (m *PipelineScmConfig) String() string            { return proto.CompactTextString(m) }
func (*PipelineScmConfig) ProtoMessage()               {}
func (*PipelineScmConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isPipelineScmConfig_Scm interface {
	isPipelineScmConfig_Scm()
}

type PipelineScmConfig_Bitbucket struct {
	Bitbucket *BitbucketAccessConfig `protobuf:"bytes,1,opt,name=bitbucket,oneof"`
}
type PipelineScmConfig_Github struct {
	Github *GithubAccessConfig `protobuf:"bytes,2,opt,name=github,oneof"`
}

func (*PipelineScmConfig_Bitbucket) isPipelineScmConfig_Scm() {}
func (*PipelineScmConfig_Github) isPipelineScmConfig_Scm()    {}

func (m *PipelineScmConfig) GetScm() isPipelineScmConfig_Scm {
	if m != nil {
		return m.Scm
	}
	return nil
}

func (m *PipelineScmConfig) GetBitbucket() *BitbucketAccessConfig {
	if x, ok := m.GetScm().(*PipelineScmConfig_Bitbucket); ok {
		return x.Bitbucket
	}
	return nil
}

func (m *PipelineScmConfig) GetGithub() *GithubAccessConfig {
	if x, ok := m.GetScm().(*PipelineScmConfig_Github); ok {
		return x.Github
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PipelineScmConfig) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PipelineScmConfig_OneofMarshaler, _PipelineScmConfig_OneofUnmarshaler, _PipelineScmConfig_OneofSizer, []interface{}{
		(*PipelineScmConfig_Bitbucket)(nil),
		(*PipelineScmConfig_Github)(nil),
	}
}

func _PipelineScmConfig_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PipelineScmConfig)
	// scm
	switch x := m.Scm.(type) {
	case *PipelineScmConfig_Bitbucket:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Bitbucket); err != nil {
			return err
		}
	case *PipelineScmConfig_Github:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Github); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PipelineScmConfig.Scm has unexpected type %T", x)
	}
	return nil
}

func _PipelineScmConfig_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PipelineScmConfig)
	switch tag {
	case 1: // scm.bitbucket
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BitbucketAccessConfig)
		err := b.DecodeMessage(msg)
		m.Scm = &PipelineScmConfig_Bitbucket{msg}
		return true, err
	case 2: // scm.github
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GithubAccessConfig)
		err := b.DecodeMessage(msg)
		m.Scm = &PipelineScmConfig_Github{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PipelineScmConfig_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PipelineScmConfig)
	// scm
	switch x := m.Scm.(type) {
	case *PipelineScmConfig_Bitbucket:
		s := proto.Size(x.Bitbucket)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PipelineScmConfig_Github:
		s := proto.Size(x.Github)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type PipelineStorageConfig struct {
	// Types that are valid to be assigned to Storage:
	//	*PipelineStorageConfig_S3
	//	*PipelineStorageConfig_Nexus
	Storage isPipelineStorageConfig_Storage `protobuf_oneof:"storage"`
}

func (m *PipelineStorageConfig) Reset()                    { *m = PipelineStorageConfig{} }
func (m *PipelineStorageConfig) String() string            { return proto.CompactTextString(m) }
func (*PipelineStorageConfig) ProtoMessage()               {}
func (*PipelineStorageConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isPipelineStorageConfig_Storage interface {
	isPipelineStorageConfig_Storage()
}

type PipelineStorageConfig_S3 struct {
	S3 *AWSConfig `protobuf:"bytes,1,opt,name=s3,oneof"`
}
type PipelineStorageConfig_Nexus struct {
	Nexus *NexusConfig `protobuf:"bytes,2,opt,name=nexus,oneof"`
}

func (*PipelineStorageConfig_S3) isPipelineStorageConfig_Storage()    {}
func (*PipelineStorageConfig_Nexus) isPipelineStorageConfig_Storage() {}

func (m *PipelineStorageConfig) GetStorage() isPipelineStorageConfig_Storage {
	if m != nil {
		return m.Storage
	}
	return nil
}

func (m *PipelineStorageConfig) GetS3() *AWSConfig {
	if x, ok := m.GetStorage().(*PipelineStorageConfig_S3); ok {
		return x.S3
	}
	return nil
}

func (m *PipelineStorageConfig) GetNexus() *NexusConfig {
	if x, ok := m.GetStorage().(*PipelineStorageConfig_Nexus); ok {
		return x.Nexus
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PipelineStorageConfig) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PipelineStorageConfig_OneofMarshaler, _PipelineStorageConfig_OneofUnmarshaler, _PipelineStorageConfig_OneofSizer, []interface{}{
		(*PipelineStorageConfig_S3)(nil),
		(*PipelineStorageConfig_Nexus)(nil),
	}
}

func _PipelineStorageConfig_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PipelineStorageConfig)
	// storage
	switch x := m.Storage.(type) {
	case *PipelineStorageConfig_S3:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.S3); err != nil {
			return err
		}
	case *PipelineStorageConfig_Nexus:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Nexus); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PipelineStorageConfig.Storage has unexpected type %T", x)
	}
	return nil
}

func _PipelineStorageConfig_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PipelineStorageConfig)
	switch tag {
	case 1: // storage.s3
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AWSConfig)
		err := b.DecodeMessage(msg)
		m.Storage = &PipelineStorageConfig_S3{msg}
		return true, err
	case 2: // storage.nexus
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NexusConfig)
		err := b.DecodeMessage(msg)
		m.Storage = &PipelineStorageConfig_Nexus{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PipelineStorageConfig_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PipelineStorageConfig)
	// storage
	switch x := m.Storage.(type) {
	case *PipelineStorageConfig_S3:
		s := proto.Size(x.S3)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PipelineStorageConfig_Nexus:
		s := proto.Size(x.Nexus)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type S3Data struct {
	Src  string `protobuf:"bytes,1,opt,name=src" json:"src,omitempty"`
	Dest string `protobuf:"bytes,2,opt,name=dest" json:"dest,omitempty"`
}

func (m *S3Data) Reset()                    { *m = S3Data{} }
func (m *S3Data) String() string            { return proto.CompactTextString(m) }
func (*S3Data) ProtoMessage()               {}
func (*S3Data) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *S3Data) GetSrc() string {
	if m != nil {
		return m.Src
	}
	return ""
}

func (m *S3Data) GetDest() string {
	if m != nil {
		return m.Dest
	}
	return ""
}

type NexusData struct {
	Src  string `protobuf:"bytes,1,opt,name=src" json:"src,omitempty"`
	Dest string `protobuf:"bytes,3,opt,name=dest" json:"dest,omitempty"`
}

func (m *NexusData) Reset()                    { *m = NexusData{} }
func (m *NexusData) String() string            { return proto.CompactTextString(m) }
func (*NexusData) ProtoMessage()               {}
func (*NexusData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *NexusData) GetSrc() string {
	if m != nil {
		return m.Src
	}
	return ""
}

func (m *NexusData) GetDest() string {
	if m != nil {
		return m.Dest
	}
	return ""
}

type PipelineInput struct {
	// Types that are valid to be assigned to Input:
	//	*PipelineInput_S3
	//	*PipelineInput_Nexus
	Input isPipelineInput_Input `protobuf_oneof:"input"`
}

func (m *PipelineInput) Reset()                    { *m = PipelineInput{} }
func (m *PipelineInput) String() string            { return proto.CompactTextString(m) }
func (*PipelineInput) ProtoMessage()               {}
func (*PipelineInput) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isPipelineInput_Input interface {
	isPipelineInput_Input()
}

type PipelineInput_S3 struct {
	S3 *S3Data `protobuf:"bytes,1,opt,name=s3,oneof"`
}
type PipelineInput_Nexus struct {
	Nexus *NexusData `protobuf:"bytes,2,opt,name=nexus,oneof"`
}

func (*PipelineInput_S3) isPipelineInput_Input()    {}
func (*PipelineInput_Nexus) isPipelineInput_Input() {}

func (m *PipelineInput) GetInput() isPipelineInput_Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *PipelineInput) GetS3() *S3Data {
	if x, ok := m.GetInput().(*PipelineInput_S3); ok {
		return x.S3
	}
	return nil
}

func (m *PipelineInput) GetNexus() *NexusData {
	if x, ok := m.GetInput().(*PipelineInput_Nexus); ok {
		return x.Nexus
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PipelineInput) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PipelineInput_OneofMarshaler, _PipelineInput_OneofUnmarshaler, _PipelineInput_OneofSizer, []interface{}{
		(*PipelineInput_S3)(nil),
		(*PipelineInput_Nexus)(nil),
	}
}

func _PipelineInput_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PipelineInput)
	// input
	switch x := m.Input.(type) {
	case *PipelineInput_S3:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.S3); err != nil {
			return err
		}
	case *PipelineInput_Nexus:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Nexus); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PipelineInput.Input has unexpected type %T", x)
	}
	return nil
}

func _PipelineInput_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PipelineInput)
	switch tag {
	case 1: // input.s3
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(S3Data)
		err := b.DecodeMessage(msg)
		m.Input = &PipelineInput_S3{msg}
		return true, err
	case 2: // input.nexus
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NexusData)
		err := b.DecodeMessage(msg)
		m.Input = &PipelineInput_Nexus{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PipelineInput_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PipelineInput)
	// input
	switch x := m.Input.(type) {
	case *PipelineInput_S3:
		s := proto.Size(x.S3)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PipelineInput_Nexus:
		s := proto.Size(x.Nexus)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type PipelineOutput struct {
	// Types that are valid to be assigned to Output:
	//	*PipelineOutput_S3
	//	*PipelineOutput_Nexus
	Output isPipelineOutput_Output `protobuf_oneof:"output"`
}

func (m *PipelineOutput) Reset()                    { *m = PipelineOutput{} }
func (m *PipelineOutput) String() string            { return proto.CompactTextString(m) }
func (*PipelineOutput) ProtoMessage()               {}
func (*PipelineOutput) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isPipelineOutput_Output interface {
	isPipelineOutput_Output()
}

type PipelineOutput_S3 struct {
	S3 *S3Data `protobuf:"bytes,1,opt,name=s3,oneof"`
}
type PipelineOutput_Nexus struct {
	Nexus *NexusData `protobuf:"bytes,2,opt,name=nexus,oneof"`
}

func (*PipelineOutput_S3) isPipelineOutput_Output()    {}
func (*PipelineOutput_Nexus) isPipelineOutput_Output() {}

func (m *PipelineOutput) GetOutput() isPipelineOutput_Output {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *PipelineOutput) GetS3() *S3Data {
	if x, ok := m.GetOutput().(*PipelineOutput_S3); ok {
		return x.S3
	}
	return nil
}

func (m *PipelineOutput) GetNexus() *NexusData {
	if x, ok := m.GetOutput().(*PipelineOutput_Nexus); ok {
		return x.Nexus
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PipelineOutput) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PipelineOutput_OneofMarshaler, _PipelineOutput_OneofUnmarshaler, _PipelineOutput_OneofSizer, []interface{}{
		(*PipelineOutput_S3)(nil),
		(*PipelineOutput_Nexus)(nil),
	}
}

func _PipelineOutput_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PipelineOutput)
	// output
	switch x := m.Output.(type) {
	case *PipelineOutput_S3:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.S3); err != nil {
			return err
		}
	case *PipelineOutput_Nexus:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Nexus); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PipelineOutput.Output has unexpected type %T", x)
	}
	return nil
}

func _PipelineOutput_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PipelineOutput)
	switch tag {
	case 1: // output.s3
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(S3Data)
		err := b.DecodeMessage(msg)
		m.Output = &PipelineOutput_S3{msg}
		return true, err
	case 2: // output.nexus
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NexusData)
		err := b.DecodeMessage(msg)
		m.Output = &PipelineOutput_Nexus{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PipelineOutput_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PipelineOutput)
	// output
	switch x := m.Output.(type) {
	case *PipelineOutput_S3:
		s := proto.Size(x.S3)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PipelineOutput_Nexus:
		s := proto.Size(x.Nexus)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type PipelineAlertConfig struct {
	// Types that are valid to be assigned to Config:
	//	*PipelineAlertConfig_Slack
	Config isPipelineAlertConfig_Config `protobuf_oneof:"config"`
}

func (m *PipelineAlertConfig) Reset()                    { *m = PipelineAlertConfig{} }
func (m *PipelineAlertConfig) String() string            { return proto.CompactTextString(m) }
func (*PipelineAlertConfig) ProtoMessage()               {}
func (*PipelineAlertConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type isPipelineAlertConfig_Config interface {
	isPipelineAlertConfig_Config()
}

type PipelineAlertConfig_Slack struct {
	Slack *SlackConfig `protobuf:"bytes,1,opt,name=slack,oneof"`
}

func (*PipelineAlertConfig_Slack) isPipelineAlertConfig_Config() {}

func (m *PipelineAlertConfig) GetConfig() isPipelineAlertConfig_Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *PipelineAlertConfig) GetSlack() *SlackConfig {
	if x, ok := m.GetConfig().(*PipelineAlertConfig_Slack); ok {
		return x.Slack
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PipelineAlertConfig) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PipelineAlertConfig_OneofMarshaler, _PipelineAlertConfig_OneofUnmarshaler, _PipelineAlertConfig_OneofSizer, []interface{}{
		(*PipelineAlertConfig_Slack)(nil),
	}
}

func _PipelineAlertConfig_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PipelineAlertConfig)
	// config
	switch x := m.Config.(type) {
	case *PipelineAlertConfig_Slack:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Slack); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PipelineAlertConfig.Config has unexpected type %T", x)
	}
	return nil
}

func _PipelineAlertConfig_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PipelineAlertConfig)
	switch tag {
	case 1: // config.slack
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SlackConfig)
		err := b.DecodeMessage(msg)
		m.Config = &PipelineAlertConfig_Slack{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PipelineAlertConfig_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PipelineAlertConfig)
	// config
	switch x := m.Config.(type) {
	case *PipelineAlertConfig_Slack:
		s := proto.Size(x.Slack)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type PipelineStep struct {
	Name      string            `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Workdir   string            `protobuf:"bytes,2,opt,name=workdir" json:"workdir,omitempty"`
	Command   string            `protobuf:"bytes,3,opt,name=command" json:"command,omitempty"`
	Image     string            `protobuf:"bytes,4,opt,name=image" json:"image,omitempty"`
	Inputs    []*PipelineInput  `protobuf:"bytes,5,rep,name=inputs" json:"inputs,omitempty"`
	Outputs   []*PipelineOutput `protobuf:"bytes,6,rep,name=outputs" json:"outputs,omitempty"`
	Timeout   int32             `protobuf:"varint,7,opt,name=timeout" json:"timeout,omitempty"`
	Skip      bool              `protobuf:"varint,8,opt,name=skip" json:"skip,omitempty"`
	DependsOn []string          `protobuf:"bytes,9,rep,name=dependsOn" json:"dependsOn,omitempty"`
}

func (m *PipelineStep) Reset()                    { *m = PipelineStep{} }
func (m *PipelineStep) String() string            { return proto.CompactTextString(m) }
func (*PipelineStep) ProtoMessage()               {}
func (*PipelineStep) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *PipelineStep) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PipelineStep) GetWorkdir() string {
	if m != nil {
		return m.Workdir
	}
	return ""
}

func (m *PipelineStep) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *PipelineStep) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *PipelineStep) GetInputs() []*PipelineInput {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *PipelineStep) GetOutputs() []*PipelineOutput {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *PipelineStep) GetTimeout() int32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *PipelineStep) GetSkip() bool {
	if m != nil {
		return m.Skip
	}
	return false
}

func (m *PipelineStep) GetDependsOn() []string {
	if m != nil {
		return m.DependsOn
	}
	return nil
}

type BasicPipeline struct {
	Alerts  []*PipelineAlertConfig   `protobuf:"bytes,1,rep,name=alerts" json:"alerts,omitempty"`
	Storage []*PipelineStorageConfig `protobuf:"bytes,2,rep,name=storage" json:"storage,omitempty"`
	Scm     []*PipelineScmConfig     `protobuf:"bytes,3,rep,name=scm" json:"scm,omitempty"`
	Steps   []*PipelineStep          `protobuf:"bytes,4,rep,name=steps" json:"steps,omitempty"`
}

func (m *BasicPipeline) Reset()                    { *m = BasicPipeline{} }
func (m *BasicPipeline) String() string            { return proto.CompactTextString(m) }
func (*BasicPipeline) ProtoMessage()               {}
func (*BasicPipeline) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *BasicPipeline) GetAlerts() []*PipelineAlertConfig {
	if m != nil {
		return m.Alerts
	}
	return nil
}

func (m *BasicPipeline) GetStorage() []*PipelineStorageConfig {
	if m != nil {
		return m.Storage
	}
	return nil
}

func (m *BasicPipeline) GetScm() []*PipelineScmConfig {
	if m != nil {
		return m.Scm
	}
	return nil
}

func (m *BasicPipeline) GetSteps() []*PipelineStep {
	if m != nil {
		return m.Steps
	}
	return nil
}

type CicdPipeline struct {
	Alerts      []*PipelineAlertConfig   `protobuf:"bytes,1,rep,name=alerts" json:"alerts,omitempty"`
	Storage     []*PipelineStorageConfig `protobuf:"bytes,2,rep,name=storage" json:"storage,omitempty"`
	Scm         []*PipelineScmConfig     `protobuf:"bytes,3,rep,name=scm" json:"scm,omitempty"`
	Quality     []*PipelineStep          `protobuf:"bytes,4,rep,name=quality" json:"quality,omitempty"`
	Build       []*PipelineStep          `protobuf:"bytes,5,rep,name=build" json:"build,omitempty"`
	Integration []*PipelineStep          `protobuf:"bytes,6,rep,name=integration" json:"integration,omitempty"`
	Promote     []*PipelineStep          `protobuf:"bytes,7,rep,name=promote" json:"promote,omitempty"`
}

func (m *CicdPipeline) Reset()                    { *m = CicdPipeline{} }
func (m *CicdPipeline) String() string            { return proto.CompactTextString(m) }
func (*CicdPipeline) ProtoMessage()               {}
func (*CicdPipeline) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *CicdPipeline) GetAlerts() []*PipelineAlertConfig {
	if m != nil {
		return m.Alerts
	}
	return nil
}

func (m *CicdPipeline) GetStorage() []*PipelineStorageConfig {
	if m != nil {
		return m.Storage
	}
	return nil
}

func (m *CicdPipeline) GetScm() []*PipelineScmConfig {
	if m != nil {
		return m.Scm
	}
	return nil
}

func (m *CicdPipeline) GetQuality() []*PipelineStep {
	if m != nil {
		return m.Quality
	}
	return nil
}

func (m *CicdPipeline) GetBuild() []*PipelineStep {
	if m != nil {
		return m.Build
	}
	return nil
}

func (m *CicdPipeline) GetIntegration() []*PipelineStep {
	if m != nil {
		return m.Integration
	}
	return nil
}

func (m *CicdPipeline) GetPromote() []*PipelineStep {
	if m != nil {
		return m.Promote
	}
	return nil
}

func init() {
	proto.RegisterType((*Loggable)(nil), "pipelines.Loggable")
	proto.RegisterType((*Log)(nil), "pipelines.Log")
	proto.RegisterType((*PipelineScmConfig)(nil), "pipelines.PipelineScmConfig")
	proto.RegisterType((*PipelineStorageConfig)(nil), "pipelines.PipelineStorageConfig")
	proto.RegisterType((*S3Data)(nil), "pipelines.S3Data")
	proto.RegisterType((*NexusData)(nil), "pipelines.NexusData")
	proto.RegisterType((*PipelineInput)(nil), "pipelines.PipelineInput")
	proto.RegisterType((*PipelineOutput)(nil), "pipelines.PipelineOutput")
	proto.RegisterType((*PipelineAlertConfig)(nil), "pipelines.PipelineAlertConfig")
	proto.RegisterType((*PipelineStep)(nil), "pipelines.PipelineStep")
	proto.RegisterType((*BasicPipeline)(nil), "pipelines.BasicPipeline")
	proto.RegisterType((*CicdPipeline)(nil), "pipelines.CicdPipeline")
	proto.RegisterEnum("pipelines.LogProducer", LogProducer_name, LogProducer_value)
}

func init() { proto.RegisterFile("pipeline.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 688 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x55, 0x4d, 0x6f, 0xd4, 0x3a,
	0x14, 0x6d, 0x26, 0x93, 0xc9, 0xe4, 0x4e, 0x5b, 0xb5, 0x7e, 0x7d, 0xef, 0x19, 0x54, 0x20, 0x0a,
	0x08, 0x8d, 0x2a, 0x88, 0x68, 0x47, 0x2a, 0x82, 0x15, 0x9d, 0x22, 0x01, 0x52, 0x45, 0xab, 0xcc,
	0x82, 0x75, 0x3e, 0x4c, 0x30, 0x33, 0x89, 0x43, 0xec, 0x88, 0x8f, 0x25, 0xff, 0x81, 0x35, 0xff,
	0x8d, 0x5f, 0x82, 0xec, 0xd8, 0x33, 0x69, 0x35, 0x55, 0x57, 0x2c, 0xd8, 0xf9, 0xda, 0xe7, 0xdc,
	0x7b, 0xce, 0xbd, 0x76, 0x02, 0xdb, 0x15, 0xad, 0xc8, 0x82, 0x96, 0x24, 0xac, 0x6a, 0x26, 0x18,
	0xf2, 0x4c, 0xcc, 0x6f, 0xef, 0xd2, 0x52, 0x90, 0xbc, 0x8e, 0x05, 0x65, 0x65, 0x7b, 0x1a, 0x1c,
	0xc3, 0xf0, 0x8c, 0xe5, 0x79, 0x9c, 0x2c, 0x08, 0x3a, 0x80, 0xfe, 0x9c, 0x96, 0x19, 0xb6, 0x7c,
	0x6b, 0xbc, 0x7d, 0xf4, 0x5f, 0xb8, 0x24, 0x86, 0x67, 0x2c, 0xbf, 0xa8, 0x59, 0xd6, 0xa4, 0xa4,
	0x8e, 0x14, 0x26, 0xb8, 0x07, 0xf6, 0x19, 0xcb, 0x11, 0x06, 0xb7, 0x20, 0x9c, 0xc7, 0x39, 0x51,
	0x2c, 0x2f, 0x32, 0x61, 0xf0, 0xc3, 0x82, 0xdd, 0x0b, 0x9d, 0x60, 0x96, 0x16, 0xa7, 0xac, 0x7c,
	0x4f, 0x73, 0xf4, 0x02, 0xbc, 0x84, 0x8a, 0xa4, 0x49, 0xe7, 0x44, 0x28, 0xc6, 0xe8, 0xc8, 0xef,
	0xd4, 0x99, 0x9a, 0xb3, 0x93, 0x34, 0x25, 0x9c, 0xb7, 0xa4, 0xd7, 0x1b, 0xd1, 0x8a, 0x84, 0x9e,
	0xc2, 0x20, 0xa7, 0xe2, 0x43, 0x93, 0xe0, 0x9e, 0xa2, 0xdf, 0xe9, 0xd0, 0x5f, 0xa9, 0x83, 0x2b,
	0x5c, 0x0d, 0x9f, 0x3a, 0x60, 0xf3, 0xb4, 0x08, 0xbe, 0xc1, 0xbf, 0x4b, 0x59, 0x82, 0xd5, 0x71,
	0x4e, 0xb4, 0xb4, 0x87, 0xd0, 0xe3, 0x13, 0xad, 0x69, 0xaf, 0x93, 0xf4, 0xe4, 0xdd, 0x6c, 0x99,
	0xab, 0xc7, 0x27, 0x28, 0x04, 0xa7, 0x24, 0x5f, 0x1a, 0xae, 0xeb, 0x77, 0xdb, 0xf4, 0x56, 0xee,
	0x2f, 0xc1, 0x2d, 0x6c, 0xea, 0x81, 0xcb, 0xdb, 0x42, 0x41, 0x08, 0x83, 0xd9, 0xe4, 0x65, 0x2c,
	0x62, 0xb4, 0x03, 0x36, 0xaf, 0x53, 0xdd, 0x33, 0xb9, 0x44, 0x08, 0xfa, 0x19, 0xe1, 0x42, 0x65,
	0xf5, 0x22, 0xb5, 0x0e, 0x0e, 0xc1, 0x53, 0x29, 0x6f, 0xa0, 0xd8, 0x1d, 0xca, 0x1c, 0xb6, 0x8c,
	0xbd, 0x37, 0x65, 0xd5, 0x08, 0x74, 0xbf, 0x63, 0x6b, 0xb7, 0xa3, 0xb5, 0x15, 0xa2, 0x3d, 0x3d,
	0xba, 0xec, 0x69, 0xef, 0xaa, 0x27, 0x0d, 0xd5, 0x8e, 0x5c, 0x70, 0xa8, 0xcc, 0x1d, 0x14, 0xb0,
	0x6d, 0x8a, 0x9d, 0x37, 0xe2, 0x0f, 0x55, 0x1b, 0xc2, 0x80, 0xa9, 0xe4, 0xc1, 0x39, 0xfc, 0x63,
	0xca, 0x9d, 0x2c, 0x48, 0x2d, 0xf4, 0xe0, 0x42, 0x70, 0xf8, 0x22, 0x4e, 0xe7, 0xba, 0x6c, 0x77,
	0x20, 0x33, 0xb9, 0xbf, 0x1a, 0x88, 0x82, 0xc9, 0x84, 0xa9, 0xda, 0x0a, 0x7e, 0xf6, 0x60, 0x73,
	0x75, 0x19, 0x48, 0x25, 0x3b, 0x5a, 0xc6, 0x85, 0xb9, 0xcb, 0x6a, 0x2d, 0xaf, 0xf8, 0x67, 0x56,
	0xcf, 0x33, 0x5a, 0xeb, 0xd9, 0x98, 0x50, 0x9e, 0xa4, 0xac, 0x28, 0xe2, 0x32, 0xd3, 0x23, 0x30,
	0x21, 0xda, 0x03, 0x87, 0x16, 0xf2, 0x51, 0xf4, 0xd5, 0x7e, 0x1b, 0xa0, 0x27, 0x30, 0x50, 0x7d,
	0xe3, 0xd8, 0xf1, 0xed, 0xf1, 0xe8, 0x08, 0x77, 0x94, 0x5e, 0x1a, 0x5a, 0xa4, 0x71, 0x68, 0x02,
	0x6e, 0xeb, 0x9d, 0xe3, 0x81, 0xa2, 0xdc, 0x5a, 0x43, 0x69, 0x5b, 0x1f, 0x19, 0xa4, 0x94, 0x25,
	0x68, 0x41, 0x58, 0x23, 0xb0, 0xeb, 0x5b, 0x63, 0x27, 0x32, 0xa1, 0xb4, 0xc7, 0xe7, 0xb4, 0xc2,
	0x43, 0xdf, 0x1a, 0x0f, 0x23, 0xb5, 0x46, 0xfb, 0xe0, 0x65, 0xa4, 0x22, 0x65, 0xc6, 0xcf, 0x4b,
	0xec, 0xf9, 0xf6, 0xd8, 0x8b, 0x56, 0x1b, 0xc1, 0x2f, 0x0b, 0xb6, 0xa6, 0x31, 0xa7, 0xa9, 0x29,
	0x86, 0x8e, 0x61, 0x10, 0xcb, 0xe6, 0x73, 0x6c, 0x29, 0x45, 0x77, 0xd7, 0x28, 0xea, 0x4c, 0x27,
	0xd2, 0x68, 0xf4, 0x7c, 0xf9, 0x0c, 0x70, 0x4f, 0x11, 0xfd, 0x35, 0xc4, 0x4b, 0x2f, 0x32, 0x32,
	0x04, 0x14, 0xaa, 0xa7, 0x8b, 0x6d, 0xc5, 0xdb, 0x5f, 0xc7, 0x33, 0x1f, 0x98, 0x48, 0x02, 0xd1,
	0x63, 0x70, 0xb8, 0x20, 0x15, 0xc7, 0x7d, 0xc5, 0xf8, 0x7f, 0x6d, 0x25, 0x52, 0x45, 0x2d, 0x2a,
	0xf8, 0x6e, 0xc3, 0xe6, 0x29, 0x4d, 0xb3, 0xbf, 0xca, 0xe3, 0x21, 0xb8, 0x9f, 0x9a, 0x78, 0x41,
	0xc5, 0xd7, 0x9b, 0x5c, 0x1a, 0x9c, 0x6c, 0x4b, 0xd2, 0xd0, 0x45, 0xa6, 0xaf, 0xdf, 0xf5, 0x6d,
	0x51, 0x28, 0xf4, 0x0c, 0x46, 0x9d, 0xff, 0x85, 0xbe, 0x80, 0xd7, 0x92, 0xba, 0x58, 0x29, 0xae,
	0xaa, 0x59, 0xc1, 0x04, 0xc1, 0xee, 0x0d, 0xe2, 0x34, 0xee, 0xe0, 0x01, 0x8c, 0x3a, 0x7f, 0x19,
	0xb4, 0x09, 0x43, 0xc3, 0xd8, 0xd9, 0x40, 0x2e, 0xd8, 0x1f, 0x59, 0xb2, 0x63, 0x25, 0x03, 0xf5,
	0xd7, 0x9a, 0xfc, 0x0e, 0x00, 0x00, 0xff, 0xff, 0xc6, 0xc0, 0xc6, 0x4a, 0xe5, 0x06, 0x00, 0x00,
}
